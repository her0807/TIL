## 웹 어플리케이션과 싱글톤

스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생함.



스프링을 사용하면 스프링 컨테이너가 싱글톤 패턴을 위한 행위들을 다 해주어

싱글톤을 유지하기 위해 들어갔던 코드들이 없어도 됨. 

DIP, OCP private 로 부터 자유로워짐.



스프링 기본 빈 등록 방식은 싱글톤이지만,

싱글톤 방식만 지원하는 것은 아님. 



## 싱글톤 방식의 주의점

여러 클라이언트와 공유하기 대문에 객체를 무상태로 유지해야함. 

특정 클라이언트가 값을 변경하는 필드가 있으면 안된다. 



## @Configuration



스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야한다. 

기존 자바 코드를 보면 무조건 객체가 세번 호출되어야하는데, 

 Configuration 을 사용하면,  스프링이 CGLIB 라는 바이트 코드 조작 라이브 러리를 사용해서 

구조 클래스를 상속받은 다른 임의의 클래스를 만들고, 그 클래스를 스프링 빈으로 등록했다!



만약에 스프링 컨테이너에 내가 찾은 클래스가 있으면? 찾아서 반환하고 없으면 컨테이너를 생성해서 리턴할 것 . 

![image](https://user-images.githubusercontent.com/26570275/124878208-d0a79000-e006-11eb-9a27-0ce8557de4e2.png)





## 정리

@Bean 만 사용해도 스프링 빈으로 등록이 되지만, 싱글톤을 보장하지 않음. 따라서 

@Configuration 을 붙여줘야지만 싱글톤이 보장 됨!





# 컴포넌트 스캔과 의존 관계 자동 주입 시작하기



## @Bean 등록을 자동으로 해보자



1) 자동으로 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다. 

2) 의존관계도 자동으로 주입하는 @Autowired 도 제공한다.

@ComponentScan



스프링 빈으로 등록하고싶은 곳에다가 `@Compoent` 라고 붙임.

그러면 빈으로만 등록이 되고 의존관계는 설정이 안됨. 

의존관계를 자동으로 주입해주는 것이` @Autowired` 를 붙이면, 

타입에 맞는 걸 찾아서 넣어줌. 

getBean(이름 , 이름) 헤서 수동으로 넣는 것처럼!

하나의 에너테이션으로 여러개 의존도 주입 가능

![image](https://user-images.githubusercontent.com/26570275/125010150-ef5a6500-e0a0-11eb-89fe-b66f3b3e1199.png)



# 컴포넌트 스캔과 스프링 컨테이너의 흐름을 파악하자



1. 컴포넌트스캔이 붙어 있으면
2. 스프링 컨테이너가 componet 가 붙어 있는 것들을 찾아서 빈으로 등록함.(싱글톤으로)
3. 빈으로 등록된 애들은 클래스이름의 앞을자만 소문자로 바뀌고 그 이름으로 등록이 되고, 
4. 이름을 변경하고 싶으면 @Componet("원하는 이름") 을 하면 된다. 

![image](https://user-images.githubusercontent.com/26570275/125010417-6db70700-e0a1-11eb-8cb5-b015e903ff65.png)





5. 그리고 나서 @Autowired 라는 어노테이션이 붙어 있으면 그 안에 있는 객체를 타입으로 스프링 컨테이너에 있는지 조회하고

   타입이 같은 걸 빈에서 꺼내준다. 

![image](https://user-images.githubusercontent.com/26570275/125010623-db633300-e0a1-11eb-8d8f-dfaf927f87d3.png)



## 컴포넌트 위치와 기본 스캔 대상



맨처음 컴포넌트 스캔을 할 때 베이스페키지를 적을 수 있음 

# @SpringBootApplication 



-> 여기에 componentScan 이 있음 그래서 자동으로 빈이 등록됨,. 



그리고!!!! 스캔 대상

> @Component . @Controller @Service @Repository @Configration

에노테이션에 에노테이션을 붙였다고 해서 연동되는 것이 아니라, 이건 스프링이 지원하는 기능이다. 



자동 빈 vs 수동 빈 두개가 이름이 겹친다면?

수동 빈이 우선순위라서 오버라이딩이 됨. 근데 이런 오류는 잡기 어려워서

이름이 같을 시, 오류가 나도록 설계가 변경됨. 



## 의존관계 주입 방법



### 생성자 주입 방법

특징 : 생성자 호출 시점에 딱 한번만 호출됨. 

### 불번, 필수 의존관계에 사용

![image](https://user-images.githubusercontent.com/26570275/125020524-f6d73980-e0b3-11eb-972a-12cc269b821f.png)

좋은 개발 습관은 한계점과 제약이 있는 것이다. 

생성자가 하나일 때는 @Autowired 가 없어도 의존성을 주입해줌., 물론 componet 나 @ bean 으로 등록된 객체에 한해서!



## 수정자주입(setter)

![image](https://user-images.githubusercontent.com/26570275/125021797-4b7bb400-e0b6-11eb-9afe-fa5058f502ac.png)

@Autowired 로 의존성을 주입해줌

스프링 라이프 사이클이 



### 선택, 변경 가능한 의존관계에 사용함. 

1. 빈을 등록하고, 의존성 주입. 



## @autowied 의 기본 동작은 주입할 대상이 없으면, 오류가 발생한다. 주입할 대상이 없어도 동작하게 하려면 @Autowired





## 일반 메서드 주입

![image](https://user-images.githubusercontent.com/26570275/125025380-89c8a180-e0bd-11eb-90dc-d8629306f0d1.png)

## 옵션 처리

주입할 스프링 빈이 없어도 동작해야할 때가 있다. 그런데 `@Autowired` 만 사용하면 `required` 의 기본 값이 



